package com.spooky.bittorrent.protocol.client.pwp.encryption

import java.nio.ByteBuffer
import scala.annotation.tailrec
import java.security.MessageDigest
import java.nio.charset.Charset

case class PublicKey(key: Array[Byte]) //768bits /96Bytes
object PublicKey {
  def from(buffer: ByteBuffer): PublicKey = {
      @tailrec
      def rec(key: Array[Byte], buffer: ByteBuffer, index: Int): Array[Byte] = index match {
        case 20 => key
        case _ => {
          key(index) = buffer.get
          rec(key, buffer, index + 1)
        }
      }
    val key = rec(Array.ofDim[Byte](96), buffer, 0)
    PublicKey(key)
  }
}
case class SecretKey(rc4key: Array[Byte]) //256Bytes
object SecretKey {
  private[encryption] def apply(local:PublicKey,remote:PublicKey):SecretKey = {
//    DH secret: S = (Ya^Xb) mod P = (Yb^Xa) mod P
    null
  }
}
case class LocalPublicKey(local: PublicKey) {
  def remotePublicKey(remote: PublicKey): SecretKey = SecretKey(local,remote)
}
object MessageStreamEncryption {
  private val UTF8 = Charset.forName("UTF8")

  private val randomKey = MessageDigest.getInstance("sha1").digest("spooky".getBytes(UTF8))
  private val dh_prime: Array[Short] = Array(
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, //
    0x21, 0x68, 0xC2, 0x34, 0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, //
    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74, 0x02, 0x0B, 0xBE, 0xA6, //
    0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD, //
    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, //
    0xF2, 0x5F, 0x14, 0x37, 0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, //
    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6, 0xF4, 0x4C, 0x42, 0xE9, //
    0xA6, 0x3A, 0x36, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x05, 0x63 //
    );
  private val generator = 2

  def publickKey: PublicKey = {
    null
  }
}
